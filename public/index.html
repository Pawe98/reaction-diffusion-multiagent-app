<!DOCTYPE html>
<html lang="en">
  <head>
    <!--<script src="https://greggman.github.io/webgl-lint/webgl-lint.js"></script>-->
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <div class="App">
      <Canvas
        id="GLCanvas"
        class="GLCanvas"
        width=200px;
        height=200px;></Canvas>
    </div>
    <button style="width: 100px; height: 50px;"onclick="toggleAnimation()">Toggle Animation</button>

    <script>
      const VertexShaderSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    
    varying vec2 v_texCoord;

    uniform vec2 u_resolution;
 
    void main() {
      // convert the position from pixels to 0.0 to 1.0
      vec2 zeroToOne = a_position / u_resolution;
   
      // convert from 0->1 to 0->2
      vec2 zeroToTwo = zeroToOne * 2.0;
   
      // convert from 0->2 to -1->+1 (clip space)
      vec2 clipSpace = zeroToTwo - 1.0;
      v_texCoord = a_texCoord;
      gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);
    }
    `;

    const FragShaderSource = `

precision highp float;
uniform highp sampler2D uPrevTexture;
uniform bool animationIsRunning;
uniform highp float u_kernel[9];
uniform float u_kernelWeight;

// Passed in from the vertex shader.
varying vec2 v_texCoord;


float laplace(in vec2 coordinate, in int channel) {


  float resolutionX = 200.0;
  float resolutionY = 200.0;
  vec2 texelSize = 1.0 / vec2(resolutionX, resolutionY);


  vec2 textureAsPixelCoord0 = fract(vec2((coordinate.x + 0.5) - 1.0, (coordinate.y + 0.5) - 1.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord1 = fract(vec2((coordinate.x + 0.5) + 0.0, (coordinate.y + 0.5) - 1.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord2 = fract(vec2((coordinate.x + 0.5) + 1.0, (coordinate.y + 0.5) - 1.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord3 = fract(vec2((coordinate.x + 0.5) - 1.0, (coordinate.y + 0.5) + 0.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord4 = fract(vec2((coordinate.x + 0.5) + 0.0, (coordinate.y + 0.5) + 0.0) / vec2(resolutionX, resolutionY)); //center pixel
  vec2 textureAsPixelCoord5 = fract(vec2((coordinate.x + 0.5) + 1.0, (coordinate.y + 0.5) + 0.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord6 = fract(vec2((coordinate.x + 0.5) - 1.0, (coordinate.y + 0.5) + 1.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord7 = fract(vec2((coordinate.x + 0.5) + 0.0, (coordinate.y + 0.5) + 1.0) / vec2(resolutionX, resolutionY)); 
  vec2 textureAsPixelCoord8 = fract(vec2((coordinate.x + 0.5) + 1.0, (coordinate.y + 0.5) + 1.0) / vec2(resolutionX, resolutionY)); 


  vec4 colorSum = texture2D(uPrevTexture, textureAsPixelCoord0, 0.0) * vec4(u_kernel[0], u_kernel[0], u_kernel[0], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord1, 0.0) * vec4(u_kernel[1], u_kernel[1], u_kernel[1], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord2, 0.0) * vec4(u_kernel[2], u_kernel[2], u_kernel[2], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord3, 0.0) * vec4(u_kernel[3], u_kernel[3], u_kernel[3], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord4, 0.0) * vec4(u_kernel[4], u_kernel[4], u_kernel[4], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord5, 0.0) * vec4(u_kernel[5], u_kernel[5], u_kernel[5], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord6, 0.0) * vec4(u_kernel[6], u_kernel[6], u_kernel[6], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord7, 0.0) * vec4(u_kernel[7], u_kernel[7], u_kernel[7], 1.0) +
  texture2D(uPrevTexture, textureAsPixelCoord8, 0.0) * vec4(u_kernel[8], u_kernel[8], u_kernel[8], 1.0);

  if(channel == 0) {
    return (colorSum).r;
  } else if(channel == 1) {
    return (colorSum).g;
  } else {
    return 1.0;
  }
  

}

float rand(vec2 co){
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {

  float dA = 1.0; //Diffusion Rate A
  float dB = 0.24; //Diffusion Rate B
  float feed = 0.055; //Feed Rate at which A is feed into
  float kill = 0.062; //Kill Rate at wich B is Removed

  float resolutionX = 200.0;
  float resolutionY = 200.0;
  
  
  if (!animationIsRunning) {

    if(rand(v_texCoord + vec2(2.123, 3.321)) > 0.5) {
      gl_FragColor = vec4(0.0,rand(v_texCoord),0.0,1.0);
    } else {
      gl_FragColor = vec4(rand(v_texCoord),0.0,0.0,1.0);
    }
        

    // if(gl_FragCoord.x + 0.5 >= 70.0 && gl_FragCoord.x + 0.5 <= 130.0 && gl_FragCoord.y + 0.5 >= 70.0 && gl_FragCoord.y + 0.5 <= 130.0) {
    //   gl_FragColor = vec4(0, 1.0, 0.0, 1.0);
      
    // } else {
    //   gl_FragColor = vec4(1.0,0.0,0.0,1);
    // }
    

    
      
    } else {

      // Sample the prevTexture color
      vec2 textureCoord = v_texCoord;

      // Round down the coordinate to the nearest pixel
      vec2 pixelCoord = floor(textureCoord * vec2(resolutionX, resolutionY)); // from 0.0

      // Sample in the middle of the pixel
      vec2 textureAsPixelCoord = fract(vec2((pixelCoord.x + 0.5), (pixelCoord.y + 0.5)) / vec2(resolutionX, resolutionY));
    
      vec4 prevTextureColor = texture2D(uPrevTexture, textureAsPixelCoord, 0.0);
      
         if(mod(pixelCoord.x, 1.0) == 0.0) {
          gl_FragColor = prevTextureColor;

            gl_FragColor = vec4(prevTextureColor.r + 
             ((dA * laplace(pixelCoord, 0)) - 
             (prevTextureColor.r *  prevTextureColor.g * prevTextureColor.g) +
             (feed * (1.0 - prevTextureColor.r))) * 1.0, 
    
     
             prevTextureColor.g + 
             ((dB * laplace(pixelCoord, 1)) +
             (prevTextureColor.r * prevTextureColor.g * prevTextureColor.g) -
             ((kill + feed) * prevTextureColor.g)) * 1.0 , 0, 1);
        }
    }
    

    
    
     
  

}

`;





      const resulution = { x: 200, y: 200 };
      const canvas = document.getElementById("GLCanvas");
      const gl = canvas.getContext("webgl");
      var frameCount = 0;
      
  

      var animationIsRunning = false;
      const toggleAnimation = () => {
      console.log("Button clicked!: " + !animationIsRunning); // Add this line
      animationIsRunning = !animationIsRunning;
      };

      
      //SHADER INITIALIZATION
      //===============================================================
      function initShader() {
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        0,
        0,
        resulution.x,
        0,
        0,
        resulution.y,
        0,
        resulution.y,
        resulution.x,
        0,
        resulution.x,
        resulution.y,
      ]),
      gl.STATIC_DRAW
    );

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, VertexShaderSource);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    console.log("Frag shader: " + FragShaderSource);
    gl.shaderSource(fragmentShader, FragShaderSource);
    gl.compileShader(fragmentShader);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    var resolutionUniformLocation = gl.getUniformLocation(
      program,
      "u_resolution"
    );
    gl.enableVertexAttribArray(positionLocation);
    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2; // 2 components per iteration
    var type = gl.FLOAT; // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0; // start at the beginning of the buffer
    gl.vertexAttribPointer(
      positionLocation,
      size,
      type,
      normalize,
      stride,
      offset
    );
    gl.uniform2f(resolutionUniformLocation, resulution.x, resulution.y);


    var texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");

    // provide texture coordinates for the rectangle.
    var texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        0,
        0,
        1,
        0,
        0,
       1,
        0,
        1,
        1,
        0,
        1,
        1,
      ]),
      gl.STATIC_DRAW
    );

    // Turn on the attribute
    gl.enableVertexAttribArray(texCoordAttributeLocation);
    // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)
    var size = 2; // 2 components per iteration
    var type = gl.FLOAT; // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0; // start at the beginning of the buffer
    gl.vertexAttribPointer(
      texCoordAttributeLocation,
      size,
      type,
      normalize,
      stride,
      offset
    );

    




    // Define several convolution kernels
    var kernels = {
      normal: [0, 0, 0, 0, 1, 0, 0, 0, 0],
      diffusion:  [0.05, 0.2, 0.05, 0.2, -1.0, 0.2, 0.05, 0.2 , 0.05],
      test:       [0.250, 0.5, 0.250, 0.5, -1.0, 0.5, 0.250, 0.5 , 0.250]
    };
    var initialSelection = "diffusion";
    
    //Bind the post processing kernels
    var kernelLocation = gl.getUniformLocation(program, "u_kernel[0]");
     // set the kernel and it's weight
     gl.uniform1fv(kernelLocation, kernels[initialSelection])

    // Bind the previous texture uniform location
    const prevTextureLocation = gl.getUniformLocation(program, "uPrevTexture");
    gl.uniform1i(prevTextureLocation, 0); // Set the texture unit to 0

    // Get the uniform location for animationIsRunning
    const animationIsRunningLocation = gl.getUniformLocation(program, "animationIsRunning");

    // Set the value of the animationIsRunning uniform
    console.log(
      "Set the value of the animationIsRunning=" + animationIsRunning + "  uniform"
    );
    gl.uniform1i(animationIsRunningLocation, animationIsRunning);

    console.log(gl.getExtension("WEBGL_draw_buffers"));
    console.log("Finished Initialization of Canvas");
  };

  // create two textures for ping-pong rendering
  const textureWidth = 200;
      const textureHeight = 200;
      const textures = [];
      for (let i = 0; i < 2; i++) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          textureWidth,
          textureHeight,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        textures.push(texture);
      }

      // Create and bind the framebuffer
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      // Attach the textures to the framebuffer
      for (let i = 0; i < 2; i++) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          textures[i],
          0
        );
      }



  //===============================================================

  //DRAW FUNCTION
  //===============================================================
  const draw = (ctx, frameCount) => {
      ctx.drawArrays(ctx.TRIANGLES, 0, 6);
      };

  //RENDER STUFF:
  function render(drawCallback) {
        frameCount++;

        // Get the uniform location for animationIsRunning
        const animationIsRunningLocation = gl.getUniformLocation(
          program,
          "animationIsRunning"
        );

        // Set the value of the animationIsRunning uniform
        console.log(
          "Set the value of the animationIsRunning=" + animationIsRunning + "  uniform"
        );
        gl.uniform1i(animationIsRunningLocation, animationIsRunning);

        // Render to the framebuffer using the current texture as input
        //The code block prepares the framebuffer and the current texture for rendering.
        //It ensures that subsequent rendering operations will be directed to
        //the framebuffer using the current texture as the color buffer.
        const currentTexture = textures[frameCount % 2]; //Important: we always render to currentTexture,
        //but in the next frame it switches to the other array position, so the currentTexture automatically
        //becomes the prev texture in the next frame.
        const prevTexture = textures[(frameCount + 1) % 2];
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          currentTexture,
          0
        );

        // Render the scene with the previous frame's texture
        gl.bindTexture(gl.TEXTURE_2D, prevTexture);
        gl.viewport(0, 0, textureWidth, textureHeight);
        gl.clearColor(0, 0, 1, 1); // clear to blue
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        drawCallback(gl, frameCount);

        // Render to the canvas using the current texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, null); //this will make it render to canvas
        gl.bindTexture(gl.TEXTURE_2D, prevTexture);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(1, 1, 1, 1); // clear to white
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        drawCallback(gl, frameCount);

        animationFrameId = window.requestAnimationFrame(() => render(drawCallback));
        

      return () => {
        window.cancelAnimationFrame(animationFrameId);
      };
      };
    
      //DRAW

      const program = gl.createProgram();
      initShader(gl, program, frameCount + 1);
      render(draw);

      
 

    </script>
  </body>
</html>
